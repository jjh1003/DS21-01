# 二叉搜索树

二叉树的特点：

1、若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。

2、若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值。

3、它的左右子树也分别可以充当为二叉查找树。

这种查找二叉树的查找正是**二分查找**的思想，可以很快着找到目的节点，查找所需的最大次数等同于二叉查找树的高度。

在插入的时候也是一样，通过一层一层的比较，最后找到适合自己的位置。时间复杂度O(logn)

**缺陷：**

当所有节点倾向于一边时就会大大增加查找时间，时间复杂度趋向于O(n)。

# 二叉平衡树(AVL树)

## 1、定义和性质

二叉平衡树是一种特殊的二叉树。

1. 具有二叉查找树的全部特性。
2. 每个节点的左子树和右子树的高度差至多等于1。

## 2、AVL树的插入

在插入的过程中，会出现一下四种情况破坏AVL树的特性，我们可以采取如下相应的旋转。

1、左-左型：做右旋。

2、右-右型：做左旋转。

3、左-右型：先做左旋，后做右旋。

4、右-左型：先做右旋，再做左旋。

- 左-左型：做右旋。

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (42).webp" alt="640 (42)" style="zoom:80%;" />

- 右-右型：做左旋转。

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (43).webp" alt="640 (43)" style="zoom: 50%;" />

- 左-右型：先做左旋，后做右旋。

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (44).webp" alt="640 (44)" style="zoom:80%;" />

- 右-左型：先做右旋，再做左旋。

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (45).webp" alt="640 (45)" style="zoom:80%;" />

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (46).webp" alt="640 (46)" style="zoom:80%;" />

## 3、AVL树的删除

AVL树的删除有4中情况：

- 删除叶子结点。操作：直接删除，然后依次向上调整为AVL树。
- 删除非叶子节点，该节点只有左孩子。操作：该节点的值替换为左孩子节点的值，然后删除左孩子节点。
- 删除非叶子节点，该节点只有右孩子。操作：该节点的值替换为右孩子节点的值，然后删除右孩子节点。
- 删除非叶子节点，该节点既有左孩子，又有右孩子。操作：该节点的值替换为该节点的前驱节点（或者后继节点），然后删除前驱节点（或者后继节点）。

# 2-3树

## 1、定义和性质

- 满足二叉树的性质
- 节点可以存放一个或两个元素
- 每个节点有两个或三个节点
- 所有叶子节点都在树的同一层

2-3树本质也是一棵搜索树，和二叉树的区别在于，2-3节点可能存放2个元素，而且每个节点可能拥有3个子节点。

<img src="E:\java\git\project\ds\ds21-01\documents\image\image-20211209105647440.png" alt="image-20211209105647440" style="zoom:80%;" />

## 2、创建规则

- 规则一：加入新节点时，不会往空的位置添加节点，而是添加到最后一个叶子结点上；
- 规则二：四节点可以分解为两个二节点组成的树，并且分解后的根节点需要向上和父节点融合。

**示例：**数组[42,37,18,12,11,6,5]使用顺序插入的方式构建2-树。

![](E:\java\git\project\ds\ds21-01\documents\image\image-20211209105811412.png)

![image-20211209105904083](E:\java\git\project\ds\ds21-01\documents\image\image-20211209105904083.png)

![image-20211209110016851](E:\java\git\project\ds\ds21-01\documents\image\image-20211209110016851.png)

![image-20211209110159771](E:\java\git\project\ds\ds21-01\documents\image\image-20211209110159771.png)

![image-20211209110304308](E:\java\git\project\ds\ds21-01\documents\image\image-20211209110304308.png)

> 我们可以看到，在创建2-3树的每一步中，整棵树始终保持平衡。

## 3、2-3树的查找

和二叉树的查找类似，通过键值的比较来决定查找的方向。

**示例** 查找成功

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (15).webp" alt="640 (15)" style="zoom:80%;" />

**示例** 查找失败

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (14).webp" alt="640 (14)" style="zoom:80%;" />

## 4、2-3树的插入

空树的插入最简单，创建一个节点即可。

对于非空树的插入主要分为4个情况：

（1）向 2- 节点中插入新节点
（2）向一棵只含 3- 节点的树中插入新节点
（3）向一个父节点为 2- 节点的 3- 节点中插入新节点
（4）向一个父节点为 3- 节点的 3- 节点中插入新节点

- 向2节点中插入新节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (16).webp" alt="640 (16)" style="zoom:80%;" />

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (18).webp" alt="640 (18)" style="zoom:80%;" />

- 向一棵只含3节点的树中插入新节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (17).webp" alt="640 (17)" style="zoom:80%;" />

- 向一个父节点为2节点的3节点中插入新节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (19).webp" alt="640 (19)" style="zoom:80%;" />

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (20).webp" alt="640 (20)" style="zoom:80%;" />

- 向一个父节点为3节点的3节点中插入新节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (21).webp" alt="640 (21)" style="zoom:80%;" />

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (22).webp" alt="640 (22)" style="zoom:80%;" />

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (23).webp" alt="640 (23)" style="zoom:80%;" />

- 分解节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (24).webp" alt="640 (24)" style="zoom:80%;" />

## 5、2-3树的删除

删除之前，要对2-3树进行一次命中查找，查找成功才可以进行删除操作。

删除分为3中情形：

（1）删除非叶子节点。
（2）删除不为2-节点的叶子节点。
（3）删除为2-节点的叶子节点。

- 删除非叶子节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (25).webp" alt="640 (25)" style="zoom:80%;" />

- 删除不为2-节点的叶子节点

  <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (26).webp" alt="640 (26)" style="zoom:80%;" />

- 删除为2-节点的叶子节点

  - 删除节点为2节点，父节点为2节点，兄弟节点为3节点

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (27).webp" alt="640 (27)" style="zoom:80%;" />

  - 删除节点为2节点，父节点为2节点，兄弟节点为2节点

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (28).webp" alt="640 (28)" style="zoom:80%;" />

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (29).webp" alt="640 (29)" style="zoom:80%;" />

  - 删除节点为2节点，父节点为3节点

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (30).webp" alt="640 (30)" style="zoom:80%;" />

  - 2-3树为满二叉树，删除叶子节点

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (31).webp" alt="640 (31)" style="zoom:80%;" />

## 6、结语

2-3 树作为一种平衡查找树，查询效率比普通的二叉排序树要稳定许多。但是2-3树需要维护两种不同类型的结点，查找和插入操作的实现需要大量的代码，而且它们所产生的额外开销可能会使算法比标准的二叉查找树更慢。

# 红黑树

2-3树已经能保持平衡，为什么我们还需要红黑树呢，这是因为2-3树这种每个节点存储1~2个元素以及拆分节点向上融合的性质不便于代码操作，于是，我们需要通过一些规则将2-3树转换为红黑树，且转换后的二叉树依然能保持平衡。

## 1、定义和性质

- 每个节点要么是黑色，要么是红色
- 根节点是黑色
- 每个叶子节点（Nil）是黑色
- 每个红色节点的两个子节点一定是黑色
- 任意一节点到每个叶子节点的路径都包含数量相同的黑节点（如果一个节点存在黑子节点，那么该节点肯定有两个子节点）

![640](E:\java\git\project\ds\ds21-01\documents\image\640.webp)

红黑树名称定义：

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (1).webp" alt="640 (1)" style="zoom:80%;" />

红黑树的平衡有三个操作：

- 左旋：以某个结点作为支点(旋转结点)，其右子结点变为旋转结点的父结点，右子结点的左子结点变为旋转结点的右子结点，左子结点保持不变。

![640 (2)](E:\java\git\project\ds\ds21-01\documents\image\640 (2).webp)

- 右旋：以某个结点作为支点(旋转结点)，其左子结点变为旋转结点的父结点，左子结点的右子结点变为旋转结点的左子结点，右子结点保持不变。

![640 (3)](E:\java\git\project\ds\ds21-01\documents\image\640 (3).webp)

- 变色：节点的颜色由红变黑或者由黑变红

> 左旋只影响旋转结点和其右子树的结构，把右子树的结点往左子树挪了；右旋只影响旋转结点和其左子树的结构，把左子树的结点往右子树挪了。
>
> 所以旋转操作是局部的。另外可以看出旋转能保持红黑树平衡的一些端详了：当一边子树的结点少了，那么向另外一边子树“借”一些结点；当一边子树的结点多了，那么向另外一边子树“租”一些结点。

## 2、红黑树查找

红黑树是一颗二叉平衡树，并且查找不会破坏树的平衡。

- 从根结点开始查找，把根结点设置为当前结点。
- 若当前结点为空，返回 null。
- 若当前结点不为空，用当前结点的 key 跟查找 key 作比较。
- 若当前结点 key 等于查找 key，那么该 key 就是查找目标，返回当前结点。
- 若当前结点 key 大于查找 key，把当前结点的左子结点设置为当前结点，重复步骤 2。
- 若当前结点 key 小于查找 key，把当前结点的右子结点设置为当前结点，重复步骤 2。

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (4).webp" alt="640 (4)" style="zoom:80%;" />

> 非常简单，但简单不代表它效率不好。正由于红黑树总保持黑色完美平衡，所以它的查找最坏时间复杂度为 O(2lgN)，也即整颗树刚好红黑相隔的时候。

## 3、红黑树插入

插入包括两部分操作：一是查找插入的位置；二是插入后自平衡

### 查找位置

查找要插入的父节点。

- 从根结点开始查找。
- 若根结点为空，那么插入结点作为根结点，结束。
- 若根结点不为空，那么把根结点作为当前结点。
- 若当前结点为 null，返回当前结点的父结点，结束。
- 若当前结点 key 等于查找 key，那么该 key 所在结点就是插入结点，更新结点的值，结束。
- 若当前结点 key 大于查找 key，把当前结点的左子结点设置为当前结点，重复步骤 4。
- 若当前结点 key 小于查找 key，把当前结点的右子结点设置为当前结点，重复步骤 4。

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (5).webp" alt="640 (5)" style="zoom:80%;" />

### 插入

插入位置已经找到，把插入节点放到正确的位置就可以了，插入节点为红色。因为父节点为黑色节点时，红黑树的黑色平衡没有被破坏，不需要做自平衡操作。但如果插入的节点是黑色，那么插入位置所在的子树黑色节点总是多1，必须做自平衡。

插入情景：

![红黑树插入情景](E:\java\git\project\ds\ds21-01\documents\image\红黑树插入情景.png)

约定：

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (6).webp" alt="640 (6)" style="zoom:80%;" />

- **情景 1：红黑树为空树**

最简单的一种情景，直接把插入结点作为根结点就行，但注意，根据红黑树性质 2：根节点是黑色。还需要把插入结点设为黑色。

**处理：**把插入结点作为根结点，并把结点设置为黑色

- **情景 2：插入结点的 Key 已存在**

插入结点的 Key 已存在，既然红黑树总保持平衡，在插入前红黑树已经是平衡的，那么把插入结点设置为将要替代结点的颜色，再把结点的值更新就完成插入。

**处理：**把 I 设为当前结点的颜色，更新当前结点的值为插入结点的值。

- **情景 3：插入结点的父结点为黑结点**

由于插入的结点是红色的，当插入结点是黑色时，并不会影响红黑树的平衡，直接插入即可，无需做自平衡。

**处理：**直接插入。

- **情景 4：插入结点的父结点为红结点**

  >  **根结点是黑色。如果插入的父结点为红结点，那么该父结点不可能为根结点，所以插入结点总是存在祖父结点。**

  - **插入情景 4.1：叔叔结点存在并且为红结点。**

    从红黑树性质 4 可以，祖父结点肯定为黑结点，因为不可以同时存在两个相连的红结点。

    那么此时该插入子树的红黑层数的情况是：黑红红。显然最简单的处理方式是把其改为：红黑红。

    **处理：**将 P 和 S 设置为黑色，将 PP 设置为红色，把 PP 设置为当前插入结点

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (7).webp" alt="640 (7)" style="zoom:80%;" />

    <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (8).webp" alt="640 (8)" style="zoom:80%;" />

    可以看到，我们把 PP 结点设为红色了，如果 PP 的父结点是黑色，那么无需再做任何处理。

    但如果 PP 的父结点是红色，根据性质 4，此时红黑树已不平衡了，所以还需要把 PP 当作新的插入结点，继续做插入操作自平衡处理，直到平衡为止。

    试想下 PP 刚好为根结点时，那么根据性质 2，我们必须把 PP 重新设为黑色，那么树的红黑结构变为：黑黑红。

    换句话说，从根结点到叶子结点的路径中，黑色结点增加了。**这也是唯一一种会增加红黑树黑色结点层数的插入情景。**

    **我们还可以总结出另外一个经验：**红黑树的生长是自底向上的。这点不同于普通的二叉查找树，普通的二叉查找树的生长是自顶向下的。

  - **插入情景 4.2：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的左子结点。**

    单纯从插入前来看，也即不算情景 4.1 自底向上处理时的情况，叔叔结点非红即为叶子结点(Nil)。

    因为如果叔叔结点为黑结点，而父结点为红结点，那么叔叔结点所在的子树的黑色结点就比父结点所在子树的多了，这不满足红黑树的性质 5。后续情景同样如此，不再多做说明了。

    前文说了，需要旋转操作时，肯定一边子树的结点多了或少了，需要租或借给另一边。插入显然是多的情况，那么把多的结点租给另一边子树就可以了。

    - **插入情景 4.2.1：插入结点是其父结点的左子结点。**

      **处理：**将 P 设为黑色，将 PP 设为红色，对 PP 进行右旋。

      <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (9).webp" alt="640 (9)" style="zoom:80%;" />

      但把 PP 设为红色，显然又会出现情景 4.1 的情况，需要自底向上处理，做多了无谓的操作，既然能自己消化就不要麻烦祖辈们啦。

    - **插入情景 4.2.2：插入结点是其父结点的右子结点。**

      **处理：**对 P 进行左旋，把 P 设置为插入结点，得到情景 4.2.1，进行情景 4.2.1 的处理

      ![640 (10)](E:\java\git\project\ds\ds21-01\documents\image\640 (10).webp)

  - **插入情景 4.3：叔叔结点不存在或为黑结点，并且插入结点的父亲结点是祖父结点的右子结点。**

    该情景对应情景 4.2，只是方向反转，不做过多说明了，直接看图。

    - **插入情景 4.3.1：插入结点是其父结点的右子结点。**

      **处理：**将 P 设为黑色，将 PP 设为红色，对 PP 进行左旋。

      <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (11).webp" alt="640 (11)" style="zoom:80%;" />

    - **插入情景 4.3.2：插入结点是其父结点的右子结点。**

      **处理：**对 P 进行右旋，把 P 设置为插入结点，得到情景 4.3.1，进行情景 4.3.1 的处理。

      ![640 (12)](E:\java\git\project\ds\ds21-01\documents\image\640 (12).webp)

## 4、红黑树删除

红黑树的删除操作也包括两部分工作：一是查找目标结点；二是删除后自平衡。

查找目标结点显然可以复用查找操作，当不存在目标结点时，忽略本次操作；当存在目标结点时，删除后就得做自平衡处理了。

删除了结点后，我们还需要找结点来替代删除结点的位置，不然子树跟父辈结点断开了，除非删除结点刚好没子结点，那么就不需要替代。

二叉树删除结点找替代结点有 3 种情景：

- 若删除结点无子结点，直接删除。
- 若删除结点只有一个子结点，用子结点替换删除结点。
- 若删除结点有两个子结点，用后继结点（大于删除结点的最小结点）替换删除结点。

基于此，上面所说的 3 种二叉树的删除情景可以相互转换并且最终都是转换为情景 1。

**情景 2：**删除结点用其唯一的子结点替换，子结点替换为删除结点后，可以认为删除的是子结点，若子结点又有两个子结点，那么相当于转换为情景 3，一直自顶向下转换，总是能转换为情景 1。（对于红黑树来说，根据性质 5.1，只存在一个子结点的结点肯定在树末了）

**情景 3：**删除结点用后继结点（肯定不存在左结点），如果后继结点有右子结点，那么相当于转换为情景 2，否则转为情景 1。

二叉树删除结点情景关系图如图 18 所示：

![640 (32)](E:\java\git\project\ds\ds21-01\documents\image\640 (32).webp)

综上所述，删除操作删除的结点可以看作删除替代结点，而替代结点最后总是在树末。

删除的操作情景如下：

![红黑树删除情景](E:\java\git\project\ds\ds21-01\documents\image\红黑树删除情景.png)

约定：

<img src="E:\java\git\project\ds\ds21-01\documents\image\640 (33).webp" alt="640 (33)" style="zoom:80%;" />

**值得特别提醒的是，R 是即将被替换到删除结点的位置的替代结点，在删除前，它还在原来所在位置参与树的子平衡，平衡后再替换到删除结点的位置，才算删除完成。**

- **删除情景1**：替换节点是红色节点

  **处理：**颜色变为删除结点的颜色。

- **删除情景2**：替换节点是黑节点

  - **删除情景2.1**：替换节点是其父节点的左子节点

    - **删除情景2.1.1**：替换节点的兄弟节点是红节点

      **处理：**将 S 设为黑色，将 P 设为红色，对 P 进行左旋，得到情景 2.1.2.3，进行情景 2.1.2.3 的处理。

      ![640 (34)](E:\java\git\project\ds\ds21-01\documents\image\640 (34).webp)

    - **删除情景2.1.2**：替换节点的兄弟节点是黑节点

      - **删除情景 2.1.2.1：**替换结点的兄弟结点的右子结点是红结点，左子结点任意颜色。

        **处理：**将 S 的颜色设为 P 的颜色，将 P 设为黑色，将 SR 设为黑色，对 P 进行左旋。

        ![640 (35)](E:\java\git\project\ds\ds21-01\documents\image\640 (35).webp)

      - **删除情景 2.1.2.2：**替换结点的兄弟结点的右子结点为黑结点，左子结点为红结点。

        **处理：**将 S 设为红色，将 SL 设为黑色，对 S 进行右旋，得到情景 2.1.2.1，进行情景 2.1.2.1 的处理。

        ![640 (36)](E:\java\git\project\ds\ds21-01\documents\image\640 (36).webp)

      - **删除情景 2.1.2.3：**替换结点的兄弟结点的子结点都为黑结点。

        **处理：**将 S 设为红色，把 P 作为新的替换结点，重新进行删除结点情景处理。

        <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (37).webp" alt="640 (37)" style="zoom:80%;" />

  - **删除情景 2.2：**替换结点是其父结点的右子结点。

    - **删除情景 2.2.1：**替换结点的兄弟结点是红结点。

      **处理：**将 S 设为黑色，将 P 设为红色，对 P 进行右旋，得到情景 2.2.2.3，进行情景 2.2.2.3 的处理。

      ![640 (38)](E:\java\git\project\ds\ds21-01\documents\image\640 (38).webp)

    - **删除情景 2.2.2：**替换结点的兄弟结点是黑结点。

      - **删除情景 2.2.2.1：**替换结点的兄弟结点的左子结点是红结点，右子结点任意颜色。

        **处理：**将 S 的颜色设为 P 的颜色，将 P 设为黑色，将 SL 设为黑色，对 P 进行右旋。

        ![640 (39)](E:\java\git\project\ds\ds21-01\documents\image\640 (39).webp)

      - **删除情景 2.2.2.2：**替换结点的兄弟结点的左子结点为黑结点，右子结点为红结点。

        **处理：**将 S 设为红色，将 SR 设为黑色，对 S 进行左旋，得到情景 2.2.2.1，进行情景 2.2.2.1 的处理。

        ![640 (40)](E:\java\git\project\ds\ds21-01\documents\image\640 (40).webp)

      - **删除情景 2.2.2.3：**替换结点的兄弟结点的子结点都为黑结点。

        **处理：**将 S 设为红色，把 P 作为新的替换结点，重新进行删除结点情景处理。

        <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (41).webp" alt="640 (41)" style="zoom:80%;" />

综上，红黑树删除后自平衡的处理可以总结为：

- 自己能搞定的自消化（情景 1）
- 自己不能搞定的叫兄弟帮忙（除了情景 1、情景 2.1.2.3 和情景 2.2.2.3）
- 兄弟都帮忙不了的，通过父母，找远方亲戚（情景2.1.2.3和情景2.2.2.3）

# B-树

B树，概括来说一个节点可以拥有2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统最优化大块数据的读和写操作。

B-tree算法减少了定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。

B树可以看做是对平衡二叉树的拓展，允许每个节点有M-1个子节点。（M是阶的意思，M>=2，比如一个M=4的4阶B树，其子节点最多的数是M-1也就是3个子节点）

1、根节点至少有两个孩子。

2、每个中间节点都包含 k - 1 个元素和 k 个孩子，其中 m/2 <= k <= m。

3、每一个叶子节点都包含 k - 1 个元素，其中 m/2 <= k <= m。

4、所有的叶子节点都位于同一侧。

5、每个节点中的元素从小到大排列，节点当中的 k - 1 个元素正好是 k 个孩子包含的元素的值域划分。

# B+树

B+树是在B树的基础上进行改造的，它的数据都在叶子节点上，同时叶子节点之间还加了指针形成链表。

为什么数据库索引一般使用B+树而不使用B树呢？

B+树支持批量加载，B树的化批量需要做局部的中序遍历，也可能要做跨层访问。

hash表比B+树更快，那为什么不用hash表呢？

和业务场景相关，如果只是选择一条数据，那确实是hash表更快，但是数据库中我们往往会选择多条数据，这个时候B+树的查询效率就要快多了。而且数据库的索引一般都在磁盘上，如果数据量大的情况下没法一次性装入内存，而B+树的设计可以允许数据分批加载。同时，B+树的高度较低，提高了查询效率。 	

# B*树

# 拓展

1. **为什么有了二叉树还要平衡二叉树?**

   二叉查找树，相信大家都接触过，二叉查找树的特点就是**左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大**，基于二叉查找树的这种特点，我们在查找某个节点的时候，可以采取类似于**二分查找**的思想，快速找到某个节点。n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为 O（logn）。之所以说是**正常情况下**，是因为二叉查找树有可能出现一种极端的情况，例如当二叉查找树几近退化为一条链表时，这样的二叉树的查找时间顿时变味了O（n），可想而知，我们必须不能让这种情况发生，所以引申处理平衡二叉树。

2. **为什么有了平衡树还需要红黑树？**

   虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求**每个节点的左子树和右子树的高度差至多等于1**，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过**左旋**和**右旋**来进行调整，使之再次成为一颗符合要求的平衡树。

   显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了**红黑树**，红黑树具有如下特点：

   - 具有二叉查找树的特点。

   - 根节点是黑色的；

   - 每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。

   - 任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。

   - 每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。

   正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。至于为什么就能够保证时间复杂度为 O(logn)，我这里就不细讲了，后面的文章可能会讲。

   不过，与平衡树不同的是，红黑树在插入、删除等操作，**不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整**，这也是我们为什么大多数情况下使用红黑树的原因。

   不过，如果你要说，单单在查找方面的效率的话，平衡树比红黑树快。

   所以，我们也可以说，**红黑树是一种不大严格的平衡树**。也可以说是一个折中发方案。

3. **2-3树和红黑树的等价性?**

对于2-3树中的2-节点来说，本身就和二叉搜索树的节点无异，可以直接转换为红黑树的一个黑节点，但是对于3-节点来说，我们需要进行一点小转换：

- 将3-节点拆开，成为一棵树，并且3-节点的左元素作为右元素的子树

- 将原来的左元素标记为红色（表示红色节点与其父节点在2-3树中曾是平级的关系）

<img src="E:\java\git\project\ds\ds21-01\documents\image\image-20211210111818422.png" alt="image-20211210111818422" style="zoom:80%;" />

我们来转换一棵复杂点的2-3树，根据上边的两条转换规则，我们将2-节点直接转换为黑色节点，将3-节点拆成一棵子树，并给左元素标上红色，这个过程应该不难理解，另外我们可以注意到，由于红色节点是由3-节点拆分而来，因此所有的红色节点都只会出现在左子树上。

![image-20211210111855874](E:\java\git\project\ds\ds21-01\documents\image\image-20211210111855874.png)

4. **文件索引和数据库索引为什么要用B树**

   例如：

   <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (47).webp" alt="640 (47)" style="zoom:80%;" />

   <img src="E:\java\git\project\ds\ds21-01\documents\image\640 (48).webp" alt="640 (48)" style="zoom: 67%;" />

   图示平衡二叉树和B树的查找过程，可以看出，都经过了4次比较。并且如果B树的每个节点存放的元素比较多的话，比较次数是会大于二叉平衡树的，那为什么会选择B树呢？

   如果单单从比较次数来讲，二叉树确实不弱于B树，但是，我们从磁盘读取数据的时候有一个很重要的因素，那就是磁盘的寻址加载次数。
   
   磁盘上的数据存储是按页分的，而我们树的每个节点是不连续的，所以基本每个节点都分配在不同的磁盘页上。比较大小是在内存中进行比较的，而磁盘每次的寻址次数要慢很多，至少是几百倍。如上图，二叉树需要4次寻址，B树只需要3次寻址，所以B树从磁盘取数据比二叉树快很多。
   
   磁盘的寻址加载次数和数的高度相关，所以我们会选择矮胖的树形结构，假如有1000个元素的话，二叉树的高度可能会达到10层，而B树也就三四层。

